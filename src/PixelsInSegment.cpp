/**
#******************************************************************************
#
# Sorting Pixels in Segmented Remote Sensing Images
#
# Copyright (C) 2019 Ziheng Sun (szhwhu@gmail.com)
#
# This source is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation; either version 2 of the License, or (at your option)
# any later version.
#
# This code is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
# details.
#
# A copy of the GNU General Public License is available on the World Wide Web
# at <http://www.gnu.org/copyleft/gpl.html>. You can also obtain it by writing
# to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
# MA 02111-1307, USA.
#
#******************************************************************************
*/

/**********************************************************************/
/* 
   Image Analysiss Library                

   \/\/\/\/\/\/\/\/\/\/
   
    This file implements the function of sorting pixels of a segmented image corresponding to vector polygons. The vector is generated from the image. This algorithm builds a map between the pixels and the polygons. The results is an image in which the values of all the pixels are set as their corresponding polygons' Id.

  Input:
	A segmented image 
	A vector generated by the image
  Output:
	An image whose pixel values are set as the Id of the polygons who contain them.

  \/\/\/\/\/\/\/\/\/\/\/
  
  Created time: May 1, 2019.  
 
  Authors: Ziheng Sun (szhwhu@gmail.com), Hui Fang.
   
*/

/**********************************************************************/

#pragma once
#include <iostream>
#include <cstring>

#include "gdal_h/gdal_priv.h"//for gdal
#include "gdal_h/ogrsf_frmts.h" //for ogr
#include "Utils.h"

#include "time.h"

std::vector<char*> split(char* str,const char* divider){
	std::vector<char*> array;
	char * pch;
  	//printf ("Splitting string \"%s\" into tokens:\n",str);
	pch = strtok (str,divider);
	while (pch != NULL)
  	{
	    	//printf ("%s\n",pch);
		array.push_back(pch);
	    	pch = strtok (NULL, divider);
  	}
	return array;
}

Point* GetInternPoint(OGRGeometry* geom,double* adfgeotransform){
	
	OGRPoint* p = new OGRPoint();
	Point* pp1 = new Point();
	
	OGRPolygon* poly = (OGRPolygon*)geom;
	OGRLinearRing* line = poly->getExteriorRing();
	OGRLineString* li = (OGRLineString*) line;
	li->getPoint(1,p);
	
	Point* insidep = new Point();
        insidep->x = p->getX();
        insidep->y = p->getY();
        Point* wininsidep = Util::rgeotransform(insidep,adfgeotransform);
        double inx = wininsidep->x+0.5;
        double iny = wininsidep->y+0.5;

	//get the eight neighbour points of the insidep
	LISTPoint* eight = new LISTPoint();

	Point* p0 = new Point();
	p0->x = inx;
	p0->y = iny;
	eight->push_back(p0);	

	Point* p1 = new Point();
	p1->x = inx;
	p1->y = iny+1.0;
	eight->push_back(p1);

	Point* p2 = new Point();
	p2->x = inx;
	p2->y = iny-1.0;
	eight->push_back(p2);
	
	Point* p3 = new Point();
	p3->x = inx+1.0;
	p3->y = iny+1.0;
	eight->push_back(p3);

	Point* p4 = new Point();
	p4->x = inx+1.0;
	p4->y = iny;
	eight->push_back(p4);

	Point* p5 = new Point();
	p5->x = inx+1.0;
	p5->y = iny-1.0;
	eight->push_back(p5);

	Point* p6 = new Point();
	p6->x = inx-1.0;
	p6->y = iny-1.0;
	eight->push_back(p6);

	Point* p7 = new Point();
	p7->x = inx-1.0;
	p7->y = iny;
	eight->push_back(p7);
	
	Point* p8 = new Point();
	p8->x = inx-1.0;
	p8->y = iny+1.0;
	eight->push_back(p8);
	
	OGRBoolean isin = false;
	int label = -1.0;
	for(LISTPoint::iterator pit = eight->begin();pit!=eight->end();pit++){
		Point* ip = *pit;
		if(ip->x<0.0||ip->y<0.0){
			continue;
		}
		Point* newp = Util::geotransform(ip,adfgeotransform);
		p = new OGRPoint();
		p->setX(newp->x);
                p->setY(newp->y);
		isin = p->Within(geom);
		if(isin){
			pp1->x = ip->x;
			pp1->y = ip->y;
			label=0;
			break;	
		}
	}	
	if(label==-1){
		std::cout << "ERR: Not found a intern point.\n";
		throw 304;	
	}
	return pp1;	
}

bool isInThePointList(Point* p, LISTPoint* listp){
	bool isin = false;
	for(LISTPoint::iterator lpit = listp->begin();lpit!=listp->end();lpit++){
		Point* thep = *lpit;
		if(thep->x==p->x&&thep->y==p->y){
			isin = true;
			break;		
		}
	}	
	return isin;
}

/**
* Add by Ziheng on 2015.9.10
*/
Point* TurnOGRPointToPixelPoint(OGRPoint* p, double* adfgeotransform){
	Point* insidep = new Point();
	insidep->x = p->getX();
	insidep->y = p->getY();
	Point* wininsidep = Util::rgeotransform(insidep,adfgeotransform);
	return wininsidep;
}
/**
* Add by Ziheng on 2015.9.10
* It should be noticed that the differences between the coordinate systems of vector and raster
* In vector, the border of polygon is clockwise. 
* In raster, the border of polygon is anticlockwise.
* Because the y axis of raster points downside while the y axis of vector points upside.
*/
int* labelBorderPixelByLinestring(int* regionmap, OGRLineString* li, double* adfgeotransform, int fid, int w, int h){
	int vertexnumber = li->getNumPoints();
	int linenumber = vertexnumber;
	for(int i=0;i<linenumber-1;i++){
		OGRPoint* p1 = new OGRPoint(); //begin point of line
		OGRPoint* p2 = new OGRPoint(); //end point of line
		li->getPoint(i,p1);
		li->getPoint(i+1,p2);
		//if(fid==263){
			//std::cout<< "original p1.x" << std::fixed<< p1->getX() << " p1.y"<< std::fixed<< p1->getY() << "\n";
			//std::cout<< "original p2.x" << std::fixed<< p2->getX() << " p2.y"<< std::fixed<< p2->getY() << "\n";
		//}
		//std::cout << adfgeotransform[0] << " " << adfgeotransform[1] << " " << adfgeotransform[2] << "\n";
		//std::cout << adfgeotransform[3] << " " << adfgeotransform[4] << " " << adfgeotransform[5] << "\n";
		Point* wp1 = TurnOGRPointToPixelPoint(p1, adfgeotransform);
		Point* wp2 = TurnOGRPointToPixelPoint(p2, adfgeotransform);
		//if(fid==263){
			//std::cout<< "p1.x:" << std::fixed<< wp1->x << " p1.y:"<< std::fixed<<wp1->y;
			//std::cout<< "p2.x:" << std::fixed<< wp2->x << " p2.y:"<< std::fixed<<wp2->y << "\n";
		//}
		//if the line is horizon
		if(wp1->y==wp2->y){
			if(wp1->x < wp2->x){
				//the pixels are above the line
				int pixely = wp1->y - 1;
				if(pixely<0) continue;
				for(double j=wp1->x;j<wp2->x;j++){
					int pixelx = j;
					if(regionmap[pixely*w+pixelx]==-1){
						regionmap[pixely*w+pixelx] = fid;
						//std::cout << "1: X:"<<pixelx << " Y:" << pixely << " Fid: " <<fid <<"\n";
					}
				}	
			}else if(wp1->x > wp2->x){
				//the pixels are beneath the line
				int pixely = wp1->y;
				for(double j=wp1->x;j>wp2->x;j--){
					int pixelx = j - 1;
					if(pixelx<0)continue;
					if(regionmap[pixely*w+pixelx]==-1){
						regionmap[pixely*w+pixelx] = fid;
						//std::cout << "2: X:"<<pixelx << " Y:" << pixely << " Fid: " <<fid <<"\n";
					}
				}
			}else{
				throw 1005;
			}		
		}
		//if the line is vertical
		else if(wp1->x == wp2->x){
			//if the coordinate system is not upside down
			//the original point is at the top-left
			if(wp1->y < wp2->y){
				//the pixels are on the right side
				int pixelx = wp1->x;
				for(double j=wp1->y;j<wp2->y;j++){
					int pixely = j;
					if(regionmap[pixely*w+pixelx]==-1){
						regionmap[pixely*w+pixelx] = fid;
						//std::cout << "3: X:"<<pixelx << " Y:" << pixely << " Fid: " <<fid <<"\n";
					}
				}
			}else if(wp1->y > wp2->y){
				//the pixels are on the left side
				int pixelx = wp1->x - 1;
				if(pixelx<0)continue;
				for(double j=wp1->y;j>wp2->y;j--){
					int pixely = j-1;
					if(pixely<0)continue;
					if(regionmap[pixely*w+pixelx]==-1){
						regionmap[pixely*w+pixelx] = fid;
						//std::cout << "4: X:"<<pixelx << " Y:" << pixely << " Fid: " <<fid <<"\n";
					}
				}
			}else{
				throw 1006;	
			}	

		}else{
			std::cout<< "original p1.x" << std::fixed<< p1->getX() << " p1.y"<< std::fixed<< p1->getY() << "\n";
			std::cout<< "original p2.x" << std::fixed<< p2->getX() << " p2.y"<< std::fixed<< p2->getY() << "\n";
			throw 1007;
		}
	}
	return regionmap;
}
/**
* Add by Ziheng on 2015.9.10
*/
int* labelBorderPixelByPolygon(int* regionmap, OGRGeometry* geom, double* adfgeotransform, int fid, int w, int h){
	OGRPolygon* poly = (OGRPolygon*)geom;
	OGRLinearRing* line = poly->getExteriorRing();
	OGRLineString* li = (OGRLineString*) line;
	regionmap = labelBorderPixelByLinestring(regionmap, li, adfgeotransform, fid, w, h);
	//process the interior rings
	int interiorringnumber = poly->getNumInteriorRings();
	if(interiorringnumber>0){
		for(int x=0;x<interiorringnumber;x++){
			//process each interior ring
			line = poly->getInteriorRing(x);
			li = (OGRLineString*) line;
			labelBorderPixelByLinestring(regionmap, li, adfgeotransform, fid, w, h);
		}
	}
	
	return regionmap;
}
/**
*
* Plan 0  - slowest method - loop all the features for each pixel
*
*/
int Plan0(char* vectorfilepath, char* rasterfilepath, char* outputfilepath){
	
	std::cout << "============Plan 0=============\n";
	GDALAllRegister();
       	OGRRegisterAll();
	CPLSetConfigOption("GDAL_FILENAME_IS_UTF8","NO");
	//open raster file	
	GDALDataset* poRDS = (GDALDataset*) GDALOpen(rasterfilepath,GA_ReadOnly);
	if(poRDS==NULL){
		std::cout << "Err: Fail to open the input raster file: "<< rasterfilepath << "\n";
		return 1;
	}
	
	//open vector file
	OGRDataSource *poVDS;
    	poVDS = OGRSFDriverRegistrar::Open( vectorfilepath, FALSE );
    	if( poVDS == NULL )
    	{
        	std::cout << "Err: Fail to open the input vector file: " << vectorfilepath << "\n";
	        return 1;
    	}
	
	//get the metadata of the raster file
	int width = poRDS->GetRasterXSize();
	int height = poRDS->GetRasterYSize();
   	int bandcount = poRDS->GetRasterCount();
   	double adfgeotransform[6];
   	poRDS->GetGeoTransform(adfgeotransform);
   	const char * projection = poRDS->GetProjectionRef();
	std::cout << "Get the metadata of the raster: \n    Width:" << width << ";\n    Height:" << height << ";\n    bandcout:"<< bandcount << "\n";
	int w = width;
	int h = height;

	//get the data of the source image
	float* source = new float[w*h];
	poRDS->RasterIO( GF_Read, 0, 0, w, h, source, w, h, GDT_Float32, 1, 0, 0, 0, 0 );

	//get the metadata of the vector file
	int layercount = poVDS->GetLayerCount();
	std::cout << layercount << "\n";
	OGRLayer* layer = poVDS->GetLayer(0);
	OGRSpatialReference* vectorref = layer->GetSpatialRef();
		
	const char* fidcolumn = layer->GetFIDColumn();
	std::cout << fidcolumn << "\n";

	//create a map between the geometry id and the image pixels
	std::map<int, float> fid2segvalue; //add by ziheng - 1/28/2014 - record the map between feature id and the corresponding pixel value of the feature in the source image of the vector
	std::map<int,Point*> fid2seed; //add by ziheng - 3/6/2014 - record the map between feature id and the interior point of the feature
	std::map<int, LISTPoint*> fid2pixels;

	//get id field
	OGRFeatureDefn* fds = layer->GetLayerDefn();	
	int idindex = fds->GetFieldIndex("Id");

        
	//timing is started from here.
	clock_t start, finish;
	double  duration;
	start = clock();

	//initialize regionmap	
	int* regionmap = new int[w*h];
	for(int i=0;i<w;i++){
		for(int j=0;j<h;j++){
			regionmap[j*w+i]=-1;		
		}
	}
	std::cout << "Initialized a region map \n";

	std::cout << "Begin to traverse the vector layer. \n";

	for(int i=0;i<h;i++){
		for(int j=0;j<w;j++){
			OGRFeature* ft;
			OGRBoolean isin = false;
			layer->ResetReading();
			while((ft=layer->GetNextFeature())!=NULL){
				const char* field = ft->GetFieldAsString(idindex);
				int fid = Format::String2Int(field);
				OGRGeometry* geom = ft->GetGeometryRef();
				OGRPoint* p = new OGRPoint();
				p->setX(j);
				p->setY(i);
				isin = p->Within(geom);
				if(isin){
					regionmap[i*w+j] = fid;	
				}
			}
		}	
	}
	
	finish = clock();
	duration = (double)(finish-start)/CLOCKS_PER_SEC;
	std::cout << "Pixel is sorted. \n";		

	std::cout<< "Feature Sortation costs "<< duration << " seconds.\n";

	//write to output file path
	GDALDriver * driver=GetGDALDriverManager()->GetDriverByName("GTiff");;
	GDALDataset * single_out = driver->Create(outputfilepath,width,height,bandcount,GDT_Int32,NULL);
	single_out->SetGeoTransform(adfgeotransform);
	single_out->SetProjection(projection);
	single_out->RasterIO(GF_Write,0,0,width,height,regionmap,width,height,GDT_Int32,bandcount, 0, 0, 0, 0);
	std::cout << "Done,\nRelease the resources.\n";
	//release the resources
	GDALClose(poRDS);
	GDALClose(single_out);
	OGRDataSource::DestroyDataSource(poVDS);

	return 0;
}

/**
*
* Plan 1  - very slow for small size image
*
*/
int Plan1(char* vectorfilepath, char* rasterfilepath, char* outputfilepath){
	
	std::cout << "============Plan 1=============\n";
	GDALAllRegister();
       	OGRRegisterAll();
	CPLSetConfigOption("GDAL_FILENAME_IS_UTF8","NO");
	//open raster file	
	GDALDataset* poRDS = (GDALDataset*) GDALOpen(rasterfilepath,GA_ReadOnly);
	if(poRDS==NULL){
		std::cout << "Err: Fail to open the input raster file: "<< rasterfilepath << "\n";
		return 1;
	}
	
	//open vector file
	OGRDataSource *poVDS;
    	poVDS = OGRSFDriverRegistrar::Open( vectorfilepath, FALSE );
    	if( poVDS == NULL )
    	{
        	std::cout << "Err: Fail to open the input vector file: " << vectorfilepath << "\n";
	        return 1;
    	}
	
	//get the metadata of the raster file
	int width = poRDS->GetRasterXSize();
	int height = poRDS->GetRasterYSize();
   	int bandcount = poRDS->GetRasterCount();
   	double adfgeotransform[6];
   	poRDS->GetGeoTransform(adfgeotransform);
   	const char * projection = poRDS->GetProjectionRef();
	std::cout << "Get the metadata of the raster: \n    Width:" << width << ";\n    Height:" << height << ";\n    bandcout:"<< bandcount << "\n";
	int w = width;
	int h = height;

	//get the data of the source image
	float* source = new float[w*h];
	poRDS->RasterIO( GF_Read, 0, 0, w, h, source, w, h, GDT_Float32, 1, 0, 0, 0, 0 );

	//get the metadata of the vector file
	int layercount = poVDS->GetLayerCount();
	std::cout << layercount << "\n";
	OGRLayer* layer = poVDS->GetLayer(0);
	OGRSpatialReference* vectorref = layer->GetSpatialRef();
		
	const char* fidcolumn = layer->GetFIDColumn();
	std::cout << fidcolumn << "\n";

	//create a map between the geometry id and the image pixels
	std::map<int, float> fid2segvalue; //add by ziheng - 1/28/2014 - record the map between feature id and the corresponding pixel value of the feature in the source image of the vector
	std::map<int,Point*> fid2seed; //add by ziheng - 3/6/2014 - record the map between feature id and the interior point of the feature
	std::map<int, LISTPoint*> fid2pixels;

	//get id field
	OGRFeatureDefn* fds = layer->GetLayerDefn();	
	int idindex = fds->GetFieldIndex("Id");

	layer->ResetReading();
        OGRFeature* ft;
	OGRBoolean isin = false;
	//timing is started from here.
	clock_t start, finish;
	double  duration;
	start = clock();
	std::cout << "Begin to traverse the vector layer. \n";
	while((ft=layer->GetNextFeature())!=NULL){
        	const char* field = ft->GetFieldAsString(idindex);
		int fid = Format::String2Int(field);
		OGRGeometry* geom = ft->GetGeometryRef();
		//add by ziheng - 1/28/2014
//		OGRPoint* interp = GetInternPoint(geom,adfgeotransform);
//		geom->Centroid(interp);
//		isin = geom->Contains(interp);
		//if the centroid is not within the geometry, find another inside point instead.
//		if(!isin){
//			std::cout << "ERR:Feature "<<fid<<" did not have a within centroid point.\n";
//			throw 304;
//		}
		//Point* insidep = new Point();
		//insidep->x = interp->getX();
		//insidep->y = interp->getY();
		//Point* wininsidep = Util::rgeotransform(insidep,adfgeotransform);
		Point* wininsidep = GetInternPoint(geom,adfgeotransform);
		
		//std::cout << " Check;;\n";
		fid2seed[fid] = wininsidep;

		int inx = (int)wininsidep->x;
		int iny = (int)wininsidep->y;
		//get the pixel value of the point(inx,iny) in the source image
		//float *pv = new float[1];
        	//poRDS1->RasterIO( GF_Read, inx, iny, 1, 1, pv, 1, 1, GDT_Float32, 1, 0, 0, 0, 0 );
		//updated by ziheng - 2014/10/8		
		//double pv = source[iny*w+inx];
		float pv = 0.0;
		poRDS->RasterIO( GF_Read, inx, iny, 1, 1, &pv, 1, 1, GDT_Float32, 1, 0, 0, 0, 0 );
		//std::cout << "Feature Id: "<< fid << ". Found an internal point: " << inx << " " << iny <<" :feature value: " << pv << "\n";
		fid2segvalue[fid] = pv;
        }


	bool* checkmatrix = new bool[w*h];	
	
	for(int i=0;i<w;i++){
		for(int j=0;j<h;j++){
			checkmatrix[j*w+i] = false;
		}
	}
	
	
	//initialize regionmap	
	int* regionmap = new int[w*h];
	for(int i=0;i<w;i++){
		for(int j=0;j<h;j++){
			regionmap[j*w+i]=-1;		
		}
	}
	std::cout << "Initialized a region map \n";


	//beginning of Plan 1
	for(std::map<int,Point*>::iterator it2 = fid2seed.begin();it2!=fid2seed.end();it2++){
		int fid2 = it2->first;
		LISTPoint* ps = fid2pixels[fid2];
		if(ps==NULL){
			ps = new LISTPoint();	
			//take the interior point as a seed, spread to all the neighbour points that have the same value and collect them as the member points of the feature.
			Point* seed = fid2seed[fid2];
			LISTPoint* pwaiting = new LISTPoint;
			pwaiting->push_back(seed);
			ps->push_back(seed);
			//set regionmap value - add by Ziheng Sun on 5/12/2016
			//std::cout << "Set Regionmap" << (y*w+x) << " as Id : " << thefid;
			int loc = (int)seed->y*w+seed->x;
			regionmap[loc] = fid2;

			int sex = (int)seed->x;
			int sey = (int)seed->y;
			checkmatrix[sey*w+sex] = true;
			double spv = source[sey*w+sex];
			
			while(!pwaiting->empty()){
				LISTPoint::iterator pwit = pwaiting->begin();
				Point* seedp = *pwit;
				//get the four neighbour points
				int sx = (int)seedp->x;
				int sy = (int)seedp->y;
				
				if(sy!=0){
					Point* up = new Point();
					up->x = sx;
					up->y = sy-1;
					double pv = source[((int)up->y)*w+(int)up->x];
					if(pv==spv&&!checkmatrix[((int)up->y)*w+(int)up->x]&&!isInThePointList(up,ps)){
						ps->push_back(up);
						checkmatrix[((int)up->y)*w+(int)up->x] = true;
						pwaiting->push_back(up);
						//set regionmap value - add by Ziheng Sun on 5/12/2016
						//std::cout << "Set Regionmap" << (y*w+x) << " as Id : " << thefid;
						loc = (int)up->y*w+up->x;
						regionmap[loc] = fid2;
					}
				}
				
				if(sy!=height-1){
					Point* down = new Point();
					down->x = sx;
					down->y = sy+1;
					double pv = source[(int)down->y*w+(int)down->x];
					if(pv==spv&&!checkmatrix[(int)down->y*w+(int)down->x]&&!isInThePointList(down,ps)){
						ps->push_back(down);
						checkmatrix[(int)down->y*w+(int)down->x] = true;
						pwaiting->push_back(down);
						//set regionmap value - add by Ziheng Sun on 5/12/2016
						//std::cout << "Set Regionmap" << (y*w+x) << " as Id : " << thefid;
						loc = (int)down->y*w+down->x;
						regionmap[loc] = fid2;
					}
				}
				
				if(sx!=0){
					Point* left = new Point();
					left->x = sx-1;
					left->y = sy;
					double pv = source[(int)left->y*w+(int)left->x];
					if(pv==spv&&!checkmatrix[(int)left->y*w+(int)left->x]&&!isInThePointList(left,ps)){
						ps->push_back(left);
						checkmatrix[(int)left->y*w+(int)left->x] = true;
						pwaiting->push_back(left);
						//set regionmap value - add by Ziheng Sun on 5/12/2016
						//std::cout << "Set Regionmap" << (y*w+x) << " as Id : " << thefid;
						loc = (int)left->y*w+left->x;
						regionmap[loc] = fid2;
					}
				}
				
				if(sx!=width-1){
					Point* right = new Point();
					right->x = sx+1;
					right->y = sy;		
					double pv = source[(int)right->y*w+(int)right->x];
					if(pv==spv&&!checkmatrix[(int)right->y*w+(int)right->x]&&!isInThePointList(right,ps)){
						ps->push_back(right);
						checkmatrix[(int)right->y*w+(int)right->x] = true;
						pwaiting->push_back(right);
						//set regionmap value - add by Ziheng Sun on 5/12/2016
						//std::cout << "Set Regionmap" << (y*w+x) << " as Id : " << thefid;
						loc = (int)right->y*w+right->x;
						regionmap[loc] = fid2;
					}
				}
				pwaiting->remove(seedp);		
			}
			//std::cout << ps->size() <<" points are found for Feature " << fid2 << ".\n";
			fid2pixels[fid2] = ps;
		}else{
			std::cout<< "Feature "<<fid2 << " is already sorted.\n";
			break;
		}
	}
	finish = clock();
	duration = (double)(finish-start)/CLOCKS_PER_SEC;
	std::cout << "Pixel is sorted. \n";		

	std::cout<< "Feature Sortation costs "<< duration << " seconds.\n";

	//write to output file path
	GDALDriver * driver=GetGDALDriverManager()->GetDriverByName("GTiff");;
	GDALDataset * single_out = driver->Create(outputfilepath,width,height,bandcount,GDT_Int32,NULL);
	single_out->SetGeoTransform(adfgeotransform);
	single_out->SetProjection(projection);
	single_out->RasterIO(GF_Write,0,0,width,height,regionmap,width,height,GDT_Int32,bandcount, 0, 0, 0, 0);
	std::cout << "Done,\nRelease the resources.\n";
	//release the resources
	GDALClose(poRDS);
	GDALClose(single_out);
	OGRDataSource::DestroyDataSource(poVDS);

	return 0;
		
	
}


/**
*
* Plan 2
*
*/
int Plan2(char* vectorfilepath, char* rasterfilepath, char* outputfilepath){
	std::cout << "============Plan 2=============\n";
	GDALAllRegister();
       	OGRRegisterAll();
	CPLSetConfigOption("GDAL_FILENAME_IS_UTF8","NO");
	//open raster file	
	GDALDataset* poRDS = (GDALDataset*) GDALOpen(rasterfilepath,GA_ReadOnly);
	if(poRDS==NULL){
		std::cout << "Err: Fail to open the input raster file: "<< rasterfilepath << "\n";
		return 1;
	}
	
	//open vector file
	OGRDataSource *poVDS;
    	poVDS = OGRSFDriverRegistrar::Open( vectorfilepath, FALSE );
    	if( poVDS == NULL )
    	{
        	std::cout << "Err: Fail to open the input vector file: " << vectorfilepath << "\n";
	        return 1;
    	}
	
	//get the metadata of the raster file
	int width = poRDS->GetRasterXSize();
	int height = poRDS->GetRasterYSize();
   	int bandcount = poRDS->GetRasterCount();
   	double adfgeotransform[6];
   	poRDS->GetGeoTransform(adfgeotransform);
   	const char * projection = poRDS->GetProjectionRef();
	std::cout << "Get the metadata of the raster: \n    Width:" << width << ";\n    Height:" << height << ";\n    bandcout:"<< bandcount << "\n";
	int w = width;
	int h = height;

	//get the data of the source image
	float* source = new float[w*h];
	poRDS->RasterIO( GF_Read, 0, 0, w, h, source, w, h, GDT_Float32, 1, 0, 0, 0, 0 );

	//get the metadata of the vector file
	int layercount = poVDS->GetLayerCount();
	std::cout << layercount << "\n";
	OGRLayer* layer = poVDS->GetLayer(0);
	OGRSpatialReference* vectorref = layer->GetSpatialRef();
		
	const char* fidcolumn = layer->GetFIDColumn();
	std::cout << fidcolumn << "\n";

	//create a map between the geometry id and the image pixels
	std::map<int, float> fid2segvalue; //add by ziheng - 1/28/2014 - record the map between feature id and the corresponding pixel value of the feature in the source image of the vector
	std::map<int,Point*> fid2seed; //add by ziheng - 3/6/2014 - record the map between feature id and the interior point of the feature
	std::map<int, LISTPoint*> fid2pixels;

	//get id field
	OGRFeatureDefn* fds = layer->GetLayerDefn();	
	int idindex = fds->GetFieldIndex("Id");

	layer->ResetReading();
        OGRFeature* ft;
	OGRBoolean isin = false;
	clock_t start, finish;
	double  duration;
	start = clock();
	std::cout << "Begin to traverse the vector layer. \n";
	while((ft=layer->GetNextFeature())!=NULL){
        	const char* field = ft->GetFieldAsString(idindex);
		int fid = Format::String2Int(field);
		OGRGeometry* geom = ft->GetGeometryRef();
		//add by ziheng - 1/28/2014
//		OGRPoint* interp = GetInternPoint(geom,adfgeotransform);
//		geom->Centroid(interp);
//		isin = geom->Contains(interp);
		//if the centroid is not within the geometry, find another inside point instead.
//		if(!isin){
//			std::cout << "ERR:Feature "<<fid<<" did not have a within centroid point.\n";
//			throw 304;
//		}
		//Point* insidep = new Point();
		//insidep->x = interp->getX();
		//insidep->y = interp->getY();
		//Point* wininsidep = Util::rgeotransform(insidep,adfgeotransform);
		Point* wininsidep = GetInternPoint(geom,adfgeotransform);
		
		//std::cout << " Check;;\n";
		fid2seed[fid] = wininsidep;

		int inx = (int)wininsidep->x;
		int iny = (int)wininsidep->y;
		//get the pixel value of the point(inx,iny) in the source image
		//float *pv = new float[1];
        	//poRDS1->RasterIO( GF_Read, inx, iny, 1, 1, pv, 1, 1, GDT_Float32, 1, 0, 0, 0, 0 );
		//updated by ziheng - 2014/10/8		
		//double pv = source[iny*w+inx];
		float pv = 0.0;
		poRDS->RasterIO( GF_Read, inx, iny, 1, 1, &pv, 1, 1, GDT_Float32, 1, 0, 0, 0, 0 );
		//std::cout << "Feature Id: "<< fid << ". Found an internal point: " << inx << " " << iny <<" :feature value: " << pv << "\n";
		fid2segvalue[fid] = pv;
        }

	//begin the major process step

	bool* checkmatrix = new bool[w*h];	
	
	for(int i=0;i<w;i++){
		for(int j=0;j<h;j++){
			checkmatrix[j*w+i] = false;
		}
	}
	
	
	//initialize regionmap	
	int* regionmap = new int[w*h];
	for(int i=0;i<w;i++){
		for(int j=0;j<h;j++){
			regionmap[j*w+i]=-1;		
		}
	}
	std::cout << "Initialized a region map \n";
	
	std::list<int>* fidlist = new std::list<int>;
	
	for(int x=0;x<width;x++){
		for(int y=0;y<height;y++){
			
			if(checkmatrix[y*width+x]){
				continue;
			}			
			
			float val = source[y*width+x];

			//std::cout << "Pixel Value: " << val << "\n";		
	
			Point* np = new Point();
			np->x = x;
			np->y = y;
			int thefid = -1;
			
			fidlist->clear();

			int cout = 0;
			for(std::map<int, float>::iterator fit = fid2segvalue.begin();fit!=fid2segvalue.end();fit++){
				int fid = fit->first;
				float v = fit->second;
				//std::cout << "Current Value:" << val << ": Feature Value: " << v << ": Feature ID"<< fid <<"\n";
				if(v==val){
					thefid = fid;
					fidlist->push_back(thefid);
					cout++;
				}
			}
			if(cout ==0){
				std::cout<< "Feature Id is not found. \n";
				throw 10000;
			}if(cout==1){
				if(thefid!=-1){
					LISTPoint* ps = fid2pixels[thefid];
					if(ps==NULL){
						ps = new LISTPoint();	
					}
					ps->push_back(np);
					fid2pixels[thefid] = ps;
					checkmatrix[y*width+x] = true;
					//set regionmap value - add by Ziheng Sun on 5/4/2016
					//std::cout << "Set Regionmap" << (y*w+x) << " as Id : " << thefid;
					regionmap[y*w+x] = thefid;
				}else{
					std::cout << "ERR: Pixel "<< x << " " << y << " didn't find a corresponding feature. \n";
					throw 303;
				}
			}else{
				//add by ziheng - 3/6/2014 - to fix the problem that some features have no points because other features take away the points that don't belong to them. 
				//if there are two regions with the same fusion values, do the following processes.
				for(std::list<int>::iterator it2 = fidlist->begin();it2!=fidlist->end();it2++){
					int fid2 = *it2;
					LISTPoint* ps = fid2pixels[fid2];
					if(ps==NULL){
						ps = new LISTPoint();	
						//take the interior point as a seed, spread to all the neighbour points that have the same value and collect them as the member points of the feature.
						Point* seed = fid2seed[fid2];
						LISTPoint* pwaiting = new LISTPoint;
						pwaiting->push_back(seed);
						ps->push_back(seed);
						int sex = (int)seed->x;
						int sey = (int)seed->y;						
						checkmatrix[sey*w+sex] = true;
						double spv = source[sey*w+sex];
						
						while(!pwaiting->empty()){
							LISTPoint::iterator pwit = pwaiting->begin();
							Point* seedp = *pwit;
							//get the four neighbour points
							int sx = (int)seedp->x;
							int sy = (int)seedp->y;
							
							if(sy!=0){
								Point* up = new Point();
								up->x = sx;
								up->y = sy-1;
								double pv = source[((int)up->y)*w+(int)up->x];
								if(pv==spv&&!checkmatrix[((int)up->y)*w+(int)up->x]&&!isInThePointList(up,ps)){
									ps->push_back(up);
									checkmatrix[((int)up->y)*w+(int)up->x] = true;
									pwaiting->push_back(up);
									//set regionmap value - add by Ziheng Sun on 5/4/2016
									//std::cout << "Set Regionmap" << (((int)up->y)*w+(int)up->x) << " as Id : " << thefid;
									regionmap[((int)up->y)*w+(int)up->x] = fid2;
								}
							}
							
							if(sy!=height-1){
								Point* down = new Point();
								down->x = sx;
								down->y = sy+1;
								double pv = source[(int)down->y*w+(int)down->x];
								if(pv==spv&&!checkmatrix[(int)down->y*w+(int)down->x]&&!isInThePointList(down,ps)){
									ps->push_back(down);
									checkmatrix[(int)down->y*w+(int)down->x] = true;
									pwaiting->push_back(down);
									//set regionmap value - add by Ziheng Sun on 5/4/2016
									//std::cout << "Set Regionmap" << ((int)down->y*w+(int)down->x) << " as Id : " << fid2;
									regionmap[(int)down->y*w+(int)down->x] = fid2;
								}
							}
							
							if(sx!=0){
								Point* left = new Point();
								left->x = sx-1;
								left->y = sy;
								double pv = source[(int)left->y*w+(int)left->x];
								if(pv==spv&&!checkmatrix[(int)left->y*w+(int)left->x]&&!isInThePointList(left,ps)){
									ps->push_back(left);
									checkmatrix[(int)left->y*w+(int)left->x] = true;
									pwaiting->push_back(left);
									//set regionmap value - add by Ziheng Sun on 5/4/2016
									//std::cout << "Set Regionmap" << ((int)left->y*w+(int)left->x) << " as Id : " << fid2;
									regionmap[(int)left->y*w+(int)left->x] = fid2;
								}
							}
							
							if(sx!=width-1){
								Point* right = new Point();
								right->x = sx+1;
								right->y = sy;		
								double pv = source[(int)right->y*w+(int)right->x];
								if(pv==spv&&!checkmatrix[(int)right->y*w+(int)right->x]&&!isInThePointList(right,ps)){
									ps->push_back(right);
									checkmatrix[(int)right->y*w+(int)right->x] = true;
									pwaiting->push_back(right);
									//set regionmap value - add by Ziheng Sun on 5/4/2016
									//std::cout << "Set Regionmap" << ((int)right->y*w+(int)right->x) << " as Id : " << fid2;
									regionmap[(int)right->y*w+(int)right->x] = fid2;
								}
							}
							pwaiting->remove(seedp);		
						}
						//std::cout<< "Feature "<<fid2 << " has a brother feature with the same fusion value.\n";
						//std::cout << ps->size() <<" points are found for it.\n";
						fid2pixels[fid2] = ps;
					}else{
						std::cout<< "Feature "<<fid2 << " is already sorted.\n";
						break;
					}
				}			
				
			}
			
		}
	}

	finish = clock();
	duration = (double)(finish-start)/CLOCKS_PER_SEC;
	std::cout << "Pixel is sorted. \n";		

	std::cout<< "Feature Sortation costs "<< duration << " seconds.\n";

	//write to output file path
	GDALDriver * driver=GetGDALDriverManager()->GetDriverByName("GTiff");;
	GDALDataset * single_out = driver->Create(outputfilepath,width,height,bandcount,GDT_Int32,NULL);
	single_out->SetGeoTransform(adfgeotransform);
	single_out->SetProjection(projection);
	single_out->RasterIO(GF_Write,0,0,width,height,regionmap,width,height,GDT_Int32,bandcount, 0, 0, 0, 0);
	std::cout << "Done,\nRelease the resources.\n";
	//release the resources
	GDALClose(poRDS);
	GDALClose(single_out);
	OGRDataSource::DestroyDataSource(poVDS);

	return 0;

}

/**
*
* Plan 3
*
*/
int Plan3(char* vectorfilepath, char* rasterfilepath, char* outputfilepath){

	std::cout << "============Plan 3=============\n";
	GDALAllRegister();
       	OGRRegisterAll();
	CPLSetConfigOption("GDAL_FILENAME_IS_UTF8","NO");
	//open raster file	
	GDALDataset* poRDS = (GDALDataset*) GDALOpen(rasterfilepath,GA_ReadOnly);
	if(poRDS==NULL){
		std::cout << "Err: Fail to open the input raster file: "<< rasterfilepath << "\n";
		return 1;
	}
	
	//open vector file
	OGRDataSource *poVDS;
    	poVDS = OGRSFDriverRegistrar::Open( vectorfilepath, FALSE );
    	if( poVDS == NULL )
    	{
        	std::cout << "Err: Fail to open the input vector file: " << vectorfilepath << "\n";
	        return 1;
    	}
	
	//get the metadata of the raster file
	int width = poRDS->GetRasterXSize();
	int height = poRDS->GetRasterYSize();
   	int bandcount = poRDS->GetRasterCount();
   	double adfgeotransform[6];
   	poRDS->GetGeoTransform(adfgeotransform);
   	const char * projection = poRDS->GetProjectionRef();
	std::cout << "Get the metadata of the raster: \n    Width:" << width << ";\n    Height:" << height << ";\n    bandcout:"<< bandcount << "\n";
	int w = width;
	int h = height;

	//get the data of the source image
	float* source = new float[w*h];
	poRDS->RasterIO( GF_Read, 0, 0, w, h, source, w, h, GDT_Float32, 1, 0, 0, 0, 0 );

	//get the metadata of the vector file
	int layercount = poVDS->GetLayerCount();
	std::cout << layercount << "\n";
	OGRLayer* layer = poVDS->GetLayer(0);
	OGRSpatialReference* vectorref = layer->GetSpatialRef();
		
	const char* fidcolumn = layer->GetFIDColumn();
	std::cout << fidcolumn << "\n";

	//create a map between the geometry id and the image pixels
	std::map<int, float> fid2segvalue; //add by ziheng - 1/28/2014 - record the map between feature id and the corresponding pixel value of the feature in the source image of the vector
	std::map<int,Point*> fid2seed; //add by ziheng - 3/6/2014 - record the map between feature id and the interior point of the feature
	std::map<int, LISTPoint*> fid2pixels;

	//get id field
	OGRFeatureDefn* fds = layer->GetLayerDefn();	
	int idindex = fds->GetFieldIndex("Id");

	layer->ResetReading();
        OGRFeature* ft;
	OGRBoolean isin = false;
	clock_t start, finish;
	double  duration;
	start = clock();
	std::cout << "Begin to traverse the vector layer. \n";
	while((ft=layer->GetNextFeature())!=NULL){
        	const char* field = ft->GetFieldAsString(idindex);
		int fid = Format::String2Int(field);
		OGRGeometry* geom = ft->GetGeometryRef();
		//add by ziheng - 1/28/2014
//		OGRPoint* interp = GetInternPoint(geom,adfgeotransform);
//		geom->Centroid(interp);
//		isin = geom->Contains(interp);
		//if the centroid is not within the geometry, find another inside point instead.
//		if(!isin){
//			std::cout << "ERR:Feature "<<fid<<" did not have a within centroid point.\n";
//			throw 304;
//		}
		//Point* insidep = new Point();
		//insidep->x = interp->getX();
		//insidep->y = interp->getY();
		//Point* wininsidep = Util::rgeotransform(insidep,adfgeotransform);
		Point* wininsidep = GetInternPoint(geom,adfgeotransform);
		
		//std::cout << " Check;;\n";
		fid2seed[fid] = wininsidep;

		int inx = (int)wininsidep->x;
		int iny = (int)wininsidep->y;
		//get the pixel value of the point(inx,iny) in the source image
		//float *pv = new float[1];
        	//poRDS1->RasterIO( GF_Read, inx, iny, 1, 1, pv, 1, 1, GDT_Float32, 1, 0, 0, 0, 0 );
		//updated by ziheng - 2014/10/8		
		//double pv = source[iny*w+inx];
		float pv = 0.0;
		poRDS->RasterIO( GF_Read, inx, iny, 1, 1, &pv, 1, 1, GDT_Float32, 1, 0, 0, 0, 0 );
		//std::cout << "Feature Id: "<< fid << ". Found an internal point: " << inx << " " << iny <<" :feature value: " << pv << "\n";
		fid2segvalue[fid] = pv;
        }

	//begin the major process step

	bool* checkmatrix = new bool[w*h];	
	
	for(int i=0;i<w;i++){
		for(int j=0;j<h;j++){
			checkmatrix[j*w+i] = false;
		}
	}

	int* regionmap = new int[w*h];
	for(int i=0;i<w;i++){
		for(int j=0;j<h;j++){
			regionmap[j*w+i]=-1;		
		}
	}
	int regioncount = 0;
	bool control = true;
	while(control){
		//get the first pixel which has region id as -1 in the line
		int seedx = -1;
		int seedy = -1;
		for(int i=0;i<w;i++){
			for(int j=0;j<h;j++){
				if(regionmap[j*w+i]==-1){
					seedx = i;
					seedy = j;
					break;	
				}	
			}
			if(seedx!=-1){
				break;			
			}
		}
		if(seedx==-1&&seedy==-1){
			std::cout << "Plan 4 loop is over.\n";
			control = false;
		}else{
			//LISTPoint ps = new LISTPoint();	
			//take the interior point as a seed, spread to all the neighbour points that have the same value and collect them as the member points of the feature.
			//Point* seed = fid2seed[fid2];
			Point* seed = new Point;
			seed->x = seedx;
			seed->y = seedy;
			LISTPoint* pwaiting = new LISTPoint;
			pwaiting->push_back(seed);
			regionmap[seedy*w+seedx] = regioncount++;
			//std::cout << "For region id : " << regionmap[seedy*w+seedx] << "\n";
			//ps->push_back(seed);
			//int sex = (int)seed->x;
			//int sey = (int)seed->y;						
			//checkmatrix[sey*w+sex] = true;
			double spv = source[seedy*width+seedx];
			//poRDS1->RasterIO( GF_Read, seedx, seedy, 1, 1, &spv, 1, 1, GDT_Float64, 1, 0, 0, 0, 0 );
			int pcout = 0;
			while(!pwaiting->empty()){
				LISTPoint::iterator pwit = pwaiting->begin();
				Point* seedp = *pwit;
				//get the four neighbour points
				int sx = (int)seedp->x;
				int sy = (int)seedp->y;
			
				if(sy!=0){
					Point* up = new Point();
					up->x = sx;
					up->y = sy-1;
					if(regionmap[((int)up->y)*w+(int)up->x]==-1){
						double pv = source[((int)up->y)*w+(int)up->x];
						//poRDS1->RasterIO( GF_Read, up->x, up->y, 1, 1, &pv, 1, 1, GDT_Float64, 1, 0, 0, 0, 0 );
						if(pv==spv){
							//ps->push_back(up);
							regionmap[((int)up->y)*w+(int)up->x] = regionmap[seedy*w+seedx];
							pwaiting->push_back(up);
							pcout++;
						}
					}
				}
			
				if(sy!=height-1){
					Point* down = new Point();
					down->x = sx;
					down->y = sy+1;
					if(regionmap[(int)down->y*w+(int)down->x]==-1){
						double pv = source[(int)down->y*w+(int)down->x];
						//poRDS1->RasterIO( GF_Read, down->x, down->y, 1, 1, &pv, 1, 1, GDT_Float64, 1, 0, 0, 0, 0 );
						if(pv==spv){
							//ps->push_back(down);
							regionmap[(int)down->y*w+(int)down->x] = regionmap[seedy*w+seedx];
							pwaiting->push_back(down);
							pcout++;
						}
					}
					
				}
			
				if(sx!=0){
					Point* left = new Point();
					left->x = sx-1;
					left->y = sy;
					if(regionmap[(int)left->y*w+(int)left->x]==-1){
						double pv = source[(int)left->y*w+(int)left->x];
						//poRDS1->RasterIO( GF_Read, left->x, left->y, 1, 1, &pv, 1, 1, GDT_Float64, 1, 0, 0, 0, 0 );
						if(pv==spv){
							regionmap[(int)left->y*w+(int)left->x] = regionmap[seedy*w+seedx];
							pwaiting->push_back(left);
							pcout++;
						}
					}
					
				}
			
				if(sx!=width-1){
					Point* right = new Point();
					right->x = sx+1;
					right->y = sy;	
					if(regionmap[(int)right->y*w+(int)right->x]==-1){
						double pv = source[(int)right->y*w+(int)right->x];
						//poRDS1->RasterIO( GF_Read, right->x, right->y, 1, 1, &pv, 1, 1, GDT_Float64, 1, 0, 0, 0, 0 );
						if(pv==spv){
							regionmap[(int)right->y*w+(int)right->x] = regionmap[seedy*w+seedx];
							pwaiting->push_back(right);
							pcout++;
						}
					}
				}
				pwaiting->remove(seedp);		
			}
			//std::cout << pcout << " pixels are found.\n";
			
		}
	}
	
	std::cout << "All the pixels in the image are labeled by region numbers.\n";
	std::cout << "Replace the regionid with featureid\n";
	int* regionmap1 = new int[w*h];
	for(std::map<int,Point*>::iterator it2 = fid2seed.begin();it2!=fid2seed.end();it2++){
		int fid2 = it2->first;
		Point* seed = it2->second;
		int x = seed->x;
		int y = seed->y;
		int thev = regionmap[y*w+x];
		for(int i=0;i<h;i++){
			for(int j=0;j<w;j++){
				if(thev==regionmap[i*w+j]){
					regionmap1[i*w+j] = fid2;
				}	
			}
		}
	}
	regionmap = regionmap1;

	std::cout << "Algorithm 3 is over.\n";	
	finish = clock();
	duration = (double)(finish-start)/CLOCKS_PER_SEC;
	std::cout << "Pixel is sorted. \n";		

	std::cout<< "Feature Sortation costs "<< duration << " seconds.\n";

	//write to output file path
	GDALDriver * driver=GetGDALDriverManager()->GetDriverByName("GTiff");;
	GDALDataset * single_out = driver->Create(outputfilepath,width,height,bandcount,GDT_Int32,NULL);
	single_out->SetGeoTransform(adfgeotransform);
	single_out->SetProjection(projection);
	single_out->RasterIO(GF_Write,0,0,width,height,regionmap,width,height,GDT_Int32,bandcount, 0, 0, 0, 0);
	std::cout << "Done,\nRelease the resources.\n";
	//release the resources
	GDALClose(poRDS);
	GDALClose(single_out);
	OGRDataSource::DestroyDataSource(poVDS);

	return 0;
}

/**
*
* Plan 4: label all the pixels along the border first.
*
*/
int Plan4(char* vectorfilepath, char* rasterfilepath, char* outputfilepath){
	std::cout << "===============Plan 4===============\n";
	GDALAllRegister();
       	OGRRegisterAll();
	CPLSetConfigOption("GDAL_FILENAME_IS_UTF8","NO");
	//open raster file	
	GDALDataset* poRDS = (GDALDataset*) GDALOpen(rasterfilepath,GA_ReadOnly);
	if(poRDS==NULL){
		std::cout << "Err: Fail to open the input raster file: "<< rasterfilepath << "\n";
		return 1;
	}
	
	//open vector file
	OGRDataSource *poVDS;
    	poVDS = OGRSFDriverRegistrar::Open( vectorfilepath, FALSE );
    	if( poVDS == NULL )
    	{
        	std::cout << "Err: Fail to open the input vector file: " << vectorfilepath << "\n";
	        return 1;
    	}
	
	//get the metadata of the raster file
	int width = poRDS->GetRasterXSize();
	int height = poRDS->GetRasterYSize();
   	int bandcount = poRDS->GetRasterCount();
   	double adfgeotransform[6];
   	poRDS->GetGeoTransform(adfgeotransform);
   	const char * projection = poRDS->GetProjectionRef();
	std::cout << "Get the metadata of the raster: \n    Width:" << width << ";\n    Height:" << height << ";\n    bandcout:"<< bandcount << "\n";

	//get the data of the source image
	int w = width;
	int h = height;
	
	//get the metadata of the vector file
	int layercount = poVDS->GetLayerCount();
	std::cout << layercount << "\n";
	OGRLayer* layer = poVDS->GetLayer(0);
	OGRSpatialReference* vectorref = layer->GetSpatialRef();
		
	const char* fidcolumn = layer->GetFIDColumn();
	std::cout << fidcolumn << "\n";
	
	//create a map between the geometry id and the image pixels
	//std::map<int, float> fid2segvalue; //add by ziheng - 1/28/2014 - record the map between feature id and the corresponding pixel value of the feature in the source image of the vector
	//std::map<int,Point*> fid2seed; //add by ziheng - 3/6/2014 - record the map between feature id and the interior point of the feature
	std::map<int, LISTPoint*> fid2pixels;

	//get id field
	OGRFeatureDefn* fds = layer->GetLayerDefn();	
	int idindex = fds->GetFieldIndex("Id");	
	layer->ResetReading();
	OGRFeature* ft;

	clock_t start, finish;
	double  duration;
	start = clock();
	std::cout << "Begin to traverse the vector layer. \n";
	std::cout << "w: " << w << " h: " << h << "\n";
	//initialize regionmap	
	int* regionmap = new int[w*h];
	for(int i=0;i<w;i++){
		for(int j=0;j<h;j++){
			regionmap[j*w+i]=-1;		
		}
	}
	std::cout << "Initialized a region map \n";
	//traverse polygons
	//label the pixels on the right side (exterior ring) or left side (interior ring) next to the border by feature id
	while((ft=layer->GetNextFeature())!=NULL){
		const char* field = ft->GetFieldAsString(idindex);
		int fid = Format::String2Int(field);
		OGRGeometry* geom = ft->GetGeometryRef();
		//Point* wininsidep = GetInternPoint(geom,adfgeotransform); this step is too slow
		regionmap = labelBorderPixelByPolygon(regionmap, geom, adfgeotransform, fid, w, h);
 	}	
	//create the map between feature id and pixels based on the support of the source image of the vector
	float* segimg = new float[w*h];
	poRDS->RasterIO( GF_Read, 0, 0, w, h, segimg, w, h, GDT_Float32, 1, 0, 0, 0, 0 );
	for(int i=0;i<w;i++){
		for(int j=0;j<h;j++){
			if(regionmap[w*j+i]==-1){
				if(i==0||j==0){
					throw 1012;	
				}
				//get the values of the current, top and left pixels
				float cv = segimg[j*w+i];
				float tv = segimg[(j-1)*w+i];
				float lv = segimg[j*w+i-1];
				if((cv-tv)==0){
					regionmap[w*j+i] = regionmap[w*(j-1)+i];	
				}else if((cv-lv)==0){
					regionmap[w*j+i] = regionmap[w*j+i-1];
				}else{
					std::cout << "x:"<<i<<";y:"<<j<<" - Current Value: "<<std::fixed << cv << " Top Value: " << tv << "Left Value: " << lv <<"\n";
					throw 1008;	
				}
			}
		}
	}

	std::cout << "All the pixels in the image are labeled by region numbers.\n";
	std::cout << "The points of each region are accumulated into a point list.\n";
	std::cout << "The point lists are set to the 'fid2pixels' map variable.\n";

	finish = clock();
	duration = (double)(finish-start)/CLOCKS_PER_SEC;
	std::cout << "Pixel is sorted. \n";		
	std::cout << "Output the sorted image to check its correctness.\n";


	std::cout<< "==>Feature Sortation costs "<< duration << " seconds.\n";	

	//write to output file path
	GDALDriver * driver=GetGDALDriverManager()->GetDriverByName("GTiff");;
	GDALDataset * single_out = driver->Create(outputfilepath,width,height,bandcount,GDT_Int32,NULL);
	single_out->SetGeoTransform(adfgeotransform);
	single_out->SetProjection(projection);
	single_out->RasterIO(GF_Write,0,0,width,height,regionmap,width,height,GDT_Int32,bandcount, 0, 0, 0, 0);
	std::cout << "Done,\nRelease the resources.\n";
	//release the resources
	GDALClose(poRDS);
	GDALClose(single_out);
	OGRDataSource::DestroyDataSource(poVDS);	 
	return 0;
}






/**
* Calculate features
*/
int SortingPixelsInSegments(char* vectorfilepath, char* rasterfilepath, char* outputfilepath, char* planno){
	int planid = Format::String2Int(planno);
	int code = -1;
	if(planid == 0){
		code = Plan0(vectorfilepath, rasterfilepath, outputfilepath);
	}else if(planid == 1){
		code = Plan1(vectorfilepath, rasterfilepath, outputfilepath);
	}else if(planid == 2){
		code = Plan2(vectorfilepath, rasterfilepath, outputfilepath);
	}else if(planid == 3){
		code = Plan3(vectorfilepath, rasterfilepath, outputfilepath);	
	}else if(planid == 4){
		code = Plan4(vectorfilepath, rasterfilepath, outputfilepath);
	}
	return code;
}

int main(int argc, char* argv[]){

	try{
		char* vectorfilepath = "";
		char* rasterfilepath = "";
		//char* segmaskfilepath = "";
		char* outputfilepath = "";
		char* planno = "";
		//char* featurelist = "";
		for(int i=0;i<argc;i++){
			if(strcmp(argv[i],"-iv")==0){
				vectorfilepath = argv[i+1];
				printf("vector file path: %s\n",vectorfilepath);
			}else if(strcmp(argv[i],"-ir")==0){
				rasterfilepath = argv[i+1];
				printf("raster file path: %s\n",rasterfilepath);
			}else if(strcmp(argv[i],"-o")==0){
				outputfilepath = argv[i+1];
				printf("output file path: %s\n",outputfilepath);
			}else if(strcmp(argv[i],"-n")==0){
				planno = argv[i+1];
				printf("Used Plan Id: %s\n",planno);	
			}else if(strcmp(argv[i],"--help")==0){
				std::cout << "Usage: [-ir  A segmented image ]" << "\n";
				std::cout << "       [-iv  A vector generated by the image]" << "\n";
				std::cout << "       [-o   An image whose pixel values are set as the Id of the polygons who contain them.]" << "\n";
				std::cout << "       [-n   The Id of the used plan.]" << "\n";
				std::cout << "       [--help display the instructions of this tool.]\n";
				return 0;
			}
		}
		if(strlen(vectorfilepath)==0){
			std::cout << "Vector file path is not found. "<<"\n";
			throw 101;
		}else if(strlen(rasterfilepath)==0){
			std::cout << "Raster file path is not found. " << "\n";
			throw 102;
		}else if(strlen(outputfilepath)==0){
			std::cout << "Output file path is not found. " << "\n";
			throw 104;
		}else if(strlen(planno)==0){
			std::cout << "Plan Id is not found. " << "\n";
			throw 105;
		}

	       	int ret = SortingPixelsInSegments(vectorfilepath, rasterfilepath, outputfilepath, planno);
	 	return ret;
	}catch(int x){
		std::cout << "Failed. Error: "<<x<<"\n";
		
	}
	return 0;
}

